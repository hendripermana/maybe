Use this rule to learn how to write tests for the Permoney codebase.

## Testing Framework

Permoney uses **Minitest** as the testing framework, which is Rails' default testing framework.

## Test Organization

Tests are organized to mirror the `app/` directory structure:

```
test/
├── controllers/          # Controller tests
├── models/              # Model tests  
├── system/              # System/integration tests
├── jobs/                # Job tests
├── mailers/             # Mailer tests
├── helpers/             # Helper tests
├── components/          # Component tests
└── fixtures/            # Test data
```

## Writing Tests

### Model Tests

Model tests should cover:
- Validations
- Associations
- Scopes
- Instance methods
- Class methods

```ruby
class UserTest < ActiveSupport::TestCase
  def setup
    @user = users(:one)
  end

  test "should be valid" do
    assert @user.valid?
  end

  test "email should be present" do
    @user.email = nil
    assert_not @user.valid?
  end
end
```

### Controller Tests

Controller tests should cover:
- Actions
- Response codes
- Redirects
- Flash messages
- Authentication/authorization

```ruby
class UsersControllerTest < ActionDispatch::IntegrationTest
  def setup
    @user = users(:one)
  end

  test "should get index" do
    get users_url
    assert_response :success
  end

  test "should create user" do
    assert_difference('User.count') do
      post users_url, params: { user: { email: 'test@example.com' } }
    end
    assert_redirected_to user_url(User.last)
  end
end
```

### System Tests

System tests simulate real user interactions:

```ruby
class UserFlowsTest < ApplicationSystemTestCase
  test "user can sign up" do
    visit new_user_registration_path
    
    fill_in "Email", with: "test@example.com"
    fill_in "Password", with: "password123"
    click_button "Sign up"
    
    assert_text "Welcome! You have signed up successfully."
  end
end
```

## Fixtures

Use fixtures for test data:

```yaml
# test/fixtures/users.yml
one:
  email: user1@example.com
  encrypted_password: <%= User.new.send(:password_digest, 'password123') %>

two:
  email: user2@example.com
  encrypted_password: <%= User.new.send(:password_digest, 'password123') %>
```

## Best Practices

1. **Test isolation**: Each test should be independent
2. **Descriptive names**: Use clear, descriptive test names
3. **Arrange-Act-Assert**: Structure tests in this pattern
4. **Use fixtures**: Don't create data in tests unless necessary
5. **Test edge cases**: Include boundary conditions and error cases
6. **Keep tests fast**: Avoid slow operations in tests

## Running Tests

```bash
# Run all tests
bin/rails test

# Run specific test file
bin/rails test test/models/user_test.rb

# Run specific test
bin/rails test test/models/user_test.rb:25

# Run with verbose output
bin/rails test -v
```

## Test Coverage

Aim for high test coverage, especially for:
- Critical business logic
- User-facing functionality
- Data integrity
- Security features

## VCR Cassettes

For external API calls, use VCR cassettes:

```ruby
require 'vcr'

VCR.use_cassette('plaid_exchange_token') do
  # API call here
end
```

Cassettes are stored in `test/vcr_cassettes/`.



  - Always prefer `OpenStruct` when creating mock instances, or in complex cases, a mock class
  - Only mock what's necessary. If you're not testing return values, don't mock a return value.


